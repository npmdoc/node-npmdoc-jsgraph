<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="https://github.com/Encapsule/jsgraph"

    >jsgraph (v0.7.0)</a>
</h1>
<h4>Generic directed graph container, and visitor algorithms based on a port of the Boost C++ Graph Library API.</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.jsgraph">module jsgraph</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsgraph.arc_core_digraph_algorithm_request">
            function <span class="apidocSignatureSpan">jsgraph.</span>arc_core_digraph_algorithm_request
            <span class="apidocSignatureSpan">(request_)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsgraph.arc_core_digraph_algorithm_visit">
            function <span class="apidocSignatureSpan">jsgraph.</span>arc_core_digraph_algorithm_visit
            <span class="apidocSignatureSpan">(request_)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsgraph.arc_core_digraph_import">
            function <span class="apidocSignatureSpan">jsgraph.</span>arc_core_digraph_import
            <span class="apidocSignatureSpan">(digraph_, jsonOrObject_)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsgraph.directed.breadthFirstTraverse">
            function <span class="apidocSignatureSpan">jsgraph.</span>directed.breadthFirstTraverse
            <span class="apidocSignatureSpan">(request_)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsgraph.directed.create">
            function <span class="apidocSignatureSpan">jsgraph.</span>directed.create
            <span class="apidocSignatureSpan">(jsonOrObject_)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsgraph.directed.createTraversalContext">
            function <span class="apidocSignatureSpan">jsgraph.</span>directed.createTraversalContext
            <span class="apidocSignatureSpan">(request_)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsgraph.directed.depthFirstTraverse">
            function <span class="apidocSignatureSpan">jsgraph.</span>directed.depthFirstTraverse
            <span class="apidocSignatureSpan">(request_)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsgraph.directed.transpose">
            function <span class="apidocSignatureSpan">jsgraph.</span>directed.transpose
            <span class="apidocSignatureSpan">(digraph_)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jsgraph.</span>arc_core_digraph</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jsgraph.</span>arc_core_digraph_export</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jsgraph.</span>arc_core_digraph_in_params</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jsgraph.</span>arc_core_graph_util</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jsgraph.</span>directed</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jsgraph.arc_core_digraph">module jsgraph.arc_core_digraph</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsgraph.arc_core_digraph.DirectedGraph">
            function <span class="apidocSignatureSpan">jsgraph.arc_core_digraph.</span>DirectedGraph
            <span class="apidocSignatureSpan">(jsonOrObject_)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsgraph.arc_core_digraph.createDirectedGraph">
            function <span class="apidocSignatureSpan">jsgraph.arc_core_digraph.</span>createDirectedGraph
            <span class="apidocSignatureSpan">(jsonOrObject_)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jsgraph.arc_core_digraph_algorithm_request">module jsgraph.arc_core_digraph_algorithm_request</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsgraph.arc_core_digraph_algorithm_request.arc_core_digraph_algorithm_request">
            function <span class="apidocSignatureSpan">jsgraph.</span>arc_core_digraph_algorithm_request
            <span class="apidocSignatureSpan">(request_)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jsgraph.arc_core_digraph_algorithm_visit">module jsgraph.arc_core_digraph_algorithm_visit</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsgraph.arc_core_digraph_algorithm_visit.arc_core_digraph_algorithm_visit">
            function <span class="apidocSignatureSpan">jsgraph.</span>arc_core_digraph_algorithm_visit
            <span class="apidocSignatureSpan">(request_)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jsgraph.arc_core_digraph_export">module jsgraph.arc_core_digraph_export</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsgraph.arc_core_digraph_export.exportJSON">
            function <span class="apidocSignatureSpan">jsgraph.arc_core_digraph_export.</span>exportJSON
            <span class="apidocSignatureSpan">(digraph_, replacer_, space_)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsgraph.arc_core_digraph_export.exportObject">
            function <span class="apidocSignatureSpan">jsgraph.arc_core_digraph_export.</span>exportObject
            <span class="apidocSignatureSpan">(digraph_)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jsgraph.arc_core_digraph_import">module jsgraph.arc_core_digraph_import</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsgraph.arc_core_digraph_import.arc_core_digraph_import">
            function <span class="apidocSignatureSpan">jsgraph.</span>arc_core_digraph_import
            <span class="apidocSignatureSpan">(digraph_, jsonOrObject_)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jsgraph.arc_core_digraph_in_params">module jsgraph.arc_core_digraph_in_params</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsgraph.arc_core_digraph_in_params.verifyEdgeReadRequest">
            function <span class="apidocSignatureSpan">jsgraph.arc_core_digraph_in_params.</span>verifyEdgeReadRequest
            <span class="apidocSignatureSpan">(request_)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsgraph.arc_core_digraph_in_params.verifyEdgeWriteRequest">
            function <span class="apidocSignatureSpan">jsgraph.arc_core_digraph_in_params.</span>verifyEdgeWriteRequest
            <span class="apidocSignatureSpan">(request_)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsgraph.arc_core_digraph_in_params.verifyVertexReadRequest">
            function <span class="apidocSignatureSpan">jsgraph.arc_core_digraph_in_params.</span>verifyVertexReadRequest
            <span class="apidocSignatureSpan">(request_)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsgraph.arc_core_digraph_in_params.verifyVertexWriteRequest">
            function <span class="apidocSignatureSpan">jsgraph.arc_core_digraph_in_params.</span>verifyVertexWriteRequest
            <span class="apidocSignatureSpan">(request_)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jsgraph.arc_core_graph_util">module jsgraph.arc_core_graph_util</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsgraph.arc_core_graph_util.JSType">
            function <span class="apidocSignatureSpan">jsgraph.arc_core_graph_util.</span>JSType
            <span class="apidocSignatureSpan">(reference_)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsgraph.arc_core_graph_util.setPropertyValueIfUndefined">
            function <span class="apidocSignatureSpan">jsgraph.arc_core_graph_util.</span>setPropertyValueIfUndefined
            <span class="apidocSignatureSpan">(reference_, propertyName_, valueOrFunction_)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jsgraph.directed">module jsgraph.directed</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsgraph.directed.breadthFirstTraverse">
            function <span class="apidocSignatureSpan">jsgraph.directed.</span>breadthFirstTraverse
            <span class="apidocSignatureSpan">(request_)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsgraph.directed.create">
            function <span class="apidocSignatureSpan">jsgraph.directed.</span>create
            <span class="apidocSignatureSpan">(jsonOrObject_)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsgraph.directed.createTraversalContext">
            function <span class="apidocSignatureSpan">jsgraph.directed.</span>createTraversalContext
            <span class="apidocSignatureSpan">(request_)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsgraph.directed.depthFirstTraverse">
            function <span class="apidocSignatureSpan">jsgraph.directed.</span>depthFirstTraverse
            <span class="apidocSignatureSpan">(request_)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsgraph.directed.transpose">
            function <span class="apidocSignatureSpan">jsgraph.directed.</span>transpose
            <span class="apidocSignatureSpan">(digraph_)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jsgraph.directed.</span>colors</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jsgraph.directed.breadthFirstTraverse">module jsgraph.directed.breadthFirstTraverse</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsgraph.directed.breadthFirstTraverse.breadthFirstTraverse">
            function <span class="apidocSignatureSpan">jsgraph.directed.</span>breadthFirstTraverse
            <span class="apidocSignatureSpan">(request_)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jsgraph.directed.create">module jsgraph.directed.create</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsgraph.directed.create.create">
            function <span class="apidocSignatureSpan">jsgraph.directed.</span>create
            <span class="apidocSignatureSpan">(jsonOrObject_)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jsgraph.directed.createTraversalContext">module jsgraph.directed.createTraversalContext</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsgraph.directed.createTraversalContext.createTraversalContext">
            function <span class="apidocSignatureSpan">jsgraph.directed.</span>createTraversalContext
            <span class="apidocSignatureSpan">(request_)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jsgraph.directed.depthFirstTraverse">module jsgraph.directed.depthFirstTraverse</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsgraph.directed.depthFirstTraverse.depthFirstTraverse">
            function <span class="apidocSignatureSpan">jsgraph.directed.</span>depthFirstTraverse
            <span class="apidocSignatureSpan">(request_)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jsgraph.directed.transpose">module jsgraph.directed.transpose</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsgraph.directed.transpose.transpose">
            function <span class="apidocSignatureSpan">jsgraph.directed.</span>transpose
            <span class="apidocSignatureSpan">(digraph_)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jsgraph" id="apidoc.module.jsgraph">module jsgraph</a></h1>


    <h2>
        <a href="#apidoc.element.jsgraph.arc_core_digraph_algorithm_request" id="apidoc.element.jsgraph.arc_core_digraph_algorithm_request">
        function <span class="apidocSignatureSpan">jsgraph.</span>arc_core_digraph_algorithm_request
        <span class="apidocSignatureSpan">(request_)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">arc_core_digraph_algorithm_request = function (request_) {

    var response = { error: null, result: null };
    var errors = [];
    var nrequest = null;
    var inBreakScope = false;

    var createTraverseContext = function() {
        var response = TRAVERSE_CONTEXT({ digraph: nrequest.digraph });
        var result = null;
        if (response.error) {
            errors.unshift(response.error);
        } else {
            result = response.result;
        }
        return result;
    };

    var getRootVertices = function() {
        return nrequest.digraph.getRootVertices();
    };

    while (!inBreakScope) {
        inBreakScope = true;

        // Verify the outer shape of the request object.
        var innerResponse = helperFunctions.JSType(request_);
        if (innerResponse !== &#x27;[object Object]&#x27;) {
            errors.unshift(&#x22;Missing request object ~. Found type &#x27;&#x22; + innerResponse + &#x22;&#x27;.&#x22;);
            break;
        }
        nrequest = {};
        innerResponse = helperFunctions.JSType(request_.digraph);
        if (innerResponse !== &#x27;[object Object]&#x27;) {
            errors.unshift(&#x22;Missing required DirectedGraph reference ~.digraph. Found type &#x27;&#x22; + innerResponse + &#x22;&#x27;.&#x22;);
            break;
        }
        nrequest.digraph = request_.digraph;
        innerResponse = helperFunctions.JSType(request_.visitor);
        if (innerResponse !== &#x27;[object Object]&#x27;) {
            errors.unshift(&#x22;Missing required visitor object reference ~.visitor. Found type &#x27;&#x22; + innerResponse + &#x22;&#x27;.&#x22;);
            break;
        }

        nrequest.visitor = request_.visitor;
        innerResponse = helperFunctions.JSType(request_.options);
        if ((innerResponse !== &#x27;[object Undefined]&#x27;) &#x26;&#x26; (innerResponse !== &#x27;[object Object]&#x27;)) {
            errors.unshift(&#x22;Options object ~.options is the wrong type. Found type &#x27;&#x22; + innerResponse + &#x22;&#x27;.&#x22;);
            break;
        }
        nrequest.options = {};
        if (innerResponse === &#x27;[object Object]&#x27;) {
            innerResponse = helperFunctions.JSType(request_.options.startVector);
            switch (innerResponse) {
            case &#x27;[object Undefined]&#x27;:
                break;
            case &#x27;[object String]&#x27;:
                nrequest.options.startVector = [ request_.options.startVector ];
                break;
            case &#x27;[object Array]&#x27;:
                nrequest.options.startVector = request_.options.startVector;
                break;
            default:
                errors.unshift(&#x22;Options object property ~.options.startVector is the wrong type. Expected either &#x27;[object String
]&#x27;, &#x27;[object Array]&#x27;, or &#x27;[object Undefined]&#x27;. Found type &#x27;&#x22; + innerResponse + &#x22;&#x27;.&#x22;);
                break;
            } // end switch

            if (errors.length) {
                break;
            }

            innerResponse = helperFunctions.JSType(request_.options.allowEmptyStartVector);
            if ((innerResponse !== &#x27;[object Undefined]&#x27;) &#x26;&#x26; (innerResponse !== &#x27;[object Boolean]&#x27;)) {
                errors.unshift(&#x22;Options object property ~.options.allowEmptyStartVector is the wrong type. Expected either &#x27;[object
 Boolean]&#x27; or &#x27;[object Undefined]. Found type &#x27;&#x22; + innerResponse + &#x22;&#x27;.&#x22;);
                break;
            }
            if (innerResponse == &#x27;[object Boolean]&#x27;) {
                nrequest.options.allowEmptyStartVector = request_.options.allowEmptyStartVector;
            }

            innerResponse = helperFunctions.JSType(request_.options.signalStart);
            if ((innerResponse !== &#x27;[object Undefined]&#x27;) &#x26;&#x26; (innerResponse !== &#x27;[object Boolean]&#x27;)) {
                errors.unshift(&#x22;Options object property ~.options.signalStart is the wrong type. Expected either &#x27;[object Boolean
]&#x27; or &#x27;[object Undefined]&#x27;. Found type &#x27;&#x22; + innerResponse + &#x22;&#x27;.&#x22;);
                break;
            }
            if (innerResponse === &#x27;[object Boolean]&#x27;) {
                nrequest.options.signalStart = request_.options.signalStart;
            }


            innerResponse = helperFunctions.JSType(request_.options.traverseContext);
            if ((innerResponse !== &#x27;[object Undefined]&#x27;) &#x26;&#x26; (inner ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsgraph.arc_core_digraph_algorithm_visit" id="apidoc.element.jsgraph.arc_core_digraph_algorithm_visit">
        function <span class="apidocSignatureSpan">jsgraph.</span>arc_core_digraph_algorithm_visit
        <span class="apidocSignatureSpan">(request_)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">arc_core_digraph_algorithm_visit = function (request_) {

    var response = { error: null, result: null };
    var errors = [];
    var inBreakScope = false;
    while (!inBreakScope) {
        inBreakScope = true;
        var visitorCallback = request_.visitor[request_.method];
        var jstype = helperFunctions.JSType(visitorCallback);
        // If the visitor function is not defined on the visitor object, return true to continue the search.
        if (jstype !== &#x27;[object Function]&#x27;) {
            if (jstype !== &#x27;[object Undefined]&#x27;) {
                errors.unshift(request_.algorithm + &#x22; visitor interface method &#x27;&#x22; + request_.method + &#x22;&#x27; is type &#x27;&#x22; + jstype + &#x22;&#x27;
instead of &#x27;[object Function]&#x27; as expected.&#x22;);
                break;
            }
            response.result = true;
            break;
        }
        var continueSearch = visitorCallback(request_.request);
        jstype = helperFunctions.JSType(continueSearch);
        if (jstype !== &#x27;[object Boolean]&#x27;) {
            errors.unshift(request_.algorithm + &#x22; visitor interface error in callback function &#x27;&#x22; + request_.method + &#x22;&#x27;. Function
 returned type &#x27;&#x22; + jstype + &#x22;&#x27; instead of expected &#x27;[object Boolean]&#x27;.&#x22;);
            break;
        }
        response.result = continueSearch;
    }
    if (errors.length) {
        response.error = errors.join(&#x27; &#x27;);
    }
    return response;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsgraph.arc_core_digraph_import" id="apidoc.element.jsgraph.arc_core_digraph_import">
        function <span class="apidocSignatureSpan">jsgraph.</span>arc_core_digraph_import
        <span class="apidocSignatureSpan">(digraph_, jsonOrObject_)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">arc_core_digraph_import = function (digraph_, jsonOrObject_) {

    var jsonParse;
    var getType = function(ref_) { return Object.prototype.toString.call(ref_); };
    var response = { error: null, result: null };
    var errors = [];
    var inBreakScope = false;

    var processVertex = function(vertexDescriptor_) {
        type = getType(vertexDescriptor_);
        if (type !== &#x27;[object Object]&#x27;) {
            errors.unshift(&#x22;JSON semantics error: Expected vertex descriptor object in &#x27;vlist&#x27; array but found &#x27;&#x22; + type + &#x22;&#x27; instead
.&#x22;);
        } else {
            type = getType(vertexDescriptor_.u);
            if (type !== &#x27;[object String]&#x27;) {
                errors.unshift(&#x22;JSON semantics error: Expected vertex descriptor property &#x27;u&#x27; to be a string but found &#x27;&#x22; + type
 + &#x22;&#x27; instead.&#x22;);
            } else {
                digraph_.addVertex({ u: vertexDescriptor_.u, p: vertexDescriptor_.p});
            }
        }
    };

    var processEdge = function (edgeDescriptor_) {
        type = getType(edgeDescriptor_);
        if (type !== &#x27;[object Object]&#x27;) {
            errors.unshift(&#x22;JSON semantics error: Expected edge descriptor object in &#x27;elist&#x27; array but found &#x27;&#x22; + type + &#x22;&#x27; instead
.&#x22;);
        } else {
            type = getType(edgeDescriptor_.e);
            if (type !== &#x27;[object Object]&#x27;) {
                errors.unshift(&#x22;JSON semantics error: Edge record in &#x27;elist&#x27; should define edge descriptor object &#x27;e&#x27; but but found
 &#x27;&#x22; + type + &#x22;&#x27; instead.&#x22;);
            } else {
                type = getType(edgeDescriptor_.e.u);
                if (type !== &#x27;[object String]&#x27;) {
                    errors.unshift(&#x22;JSON semantics error: Expected edge descriptor property &#x27;e.u&#x27; to be a string but found &#x27;&#x22; +
type + &#x22;&#x27; instead.&#x22;);
                } else {
                    type = getType(edgeDescriptor_.e.v);
                    if (type !== &#x27;[object String]&#x27;) {
                        errors.unshift(&#x22;JSON semantics error: Expected edge descriptor property &#x27;e.v&#x27; to be a string but found &#x27;&#x22; +
type + &#x22;&#x27; instead.&#x22;);
                    } else {
                        digraph_.addEdge({ e: edgeDescriptor_.e, p: edgeDescriptor_.p});
                    }
                }
            }
        }
    };

    while (!inBreakScope) {
        inBreakScope = true;

        var type = getType(jsonOrObject_);
        switch (type) {
        case &#x27;[object String]&#x27;:
            try {
                jsonParse = JSON.parse(jsonOrObject_);
            } catch (exception_) {
                errors.unshift(&#x22;Exception occurred while parsing JSON: &#x22; + exception_.message);
            }
            break;
        case &#x27;[object Object]&#x27;:
            jsonParse = jsonOrObject_;
            break;
        default:
            errors.unshift(&#x22;Invalid reference to &#x27;&#x22; + type + &#x22;&#x27; passed instead of expected JSON (or equivalent object) reference
.&#x22;);
        }
        if (errors.length) {
            break;
        }

        type = getType(jsonParse);
        if (type !== &#x27;[object Object]&#x27;) {
            errors.unshift(&#x22;JSON semantics error: Expected top-level object but found &#x27;&#x22; + type + &#x22;&#x27;.&#x22;);
            break;
        }

        type = getType(jsonParse.name);
        switch (type) {
        case &#x27;[object Undefined]&#x27;:
            jsonParse.name = &#x22;&#x22;;
            break;
        case &#x27;[object String]&#x27;:
            break;
        default:
            errors.unshift(&#x22;JSON semantics error: Expected &#x27;name&#x27; to be a string but found &#x27;&#x22; + type + &#x22;&#x27;.&#x22;);
            break;
        }
        digraph_.setGraphName(jsonParse.name);

        type = getType(jsonParse.description);
        switch (type) {
        case &#x27;[object Undefined]&#x27;:
            jsonParse.description = &#x22;&#x22;;
            break;
        case &#x27;[object String]&#x27;:
            break;
        default:
            error.unshift(&#x22;JSON semantics error: Expected &#x27;description&#x27; to be a string but found &#x27;&#x22; + type + &#x22;&#x27;.&#x22;);
            break;
        }
        digraph_.setGraphDescription(jsonParse.description);

        type = getType(jsonParse.vlist);
        switch (type) {
        case &#x27;[object Undefined]&#x27; ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsgraph.directed.breadthFirstTraverse" id="apidoc.element.jsgraph.directed.breadthFirstTraverse">
        function <span class="apidocSignatureSpan">jsgraph.</span>directed.breadthFirstTraverse
        <span class="apidocSignatureSpan">(request_)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">directed.breadthFirstTraverse = function (request_) {

    var nrequest = null; // normalized request object
    var response = { error: null, result: null };
    var errors = [];
    var continueSearch = true;
    var inBreakScope = false;
    var searchQueue = [];

    while (!inBreakScope) {
        inBreakScope = true;
        var index, vertexId;

        var innerResponse = normalizeRequest(request_);
        if (innerResponse.error) {
            errors.unshift(innerResponse.error);
            break;
        }
        nrequest = innerResponse.result;

        // initializeVertex visitor callback.
        if (nrequest.options.traverseContext.searchStatus === &#x27;pending&#x27;) {
            for (vertexId in nrequest.options.traverseContext.colorMap) {
                innerResponse = visitorCallback({ algorithm: algorithmName, visitor: nrequest.visitor, method: &#x27;initializeVertex
&#x27;, request: { u: vertexId, g: nrequest.digraph }});
                if (innerResponse.error) {
                    errors.unshift(innerResponse.error);
                    break;
                }
                continueSearch = innerResponse.result;
                if (!continueSearch) {
                    break;
                }
            }
        } // if searchStatus &#x27;pending&#x27;

        nrequest.options.traverseContext.searchStatus = &#x27;active&#x27;;

        if (errors.length || !continueSearch) {
            break;
        }

        // Initialize the BF visit or search.
        // Note that all that distinguishes visit from search is the number of starting vertices. One -&#x3e; visit, N -&#x3e; search.

        for (index in nrequest.options.startVector) {
            var startingVertexId = nrequest.options.startVector[index];
            // Ensure the starting vertex is in the graph container.
            if (!nrequest.digraph.isVertex(startingVertexId)) {
                errors.unshift(&#x22;BFT request failed. Vertex &#x27;&#x22; + startingVertexId + &#x22;&#x27; not found in specfied directed graph container
.&#x22;);
                break;
            }
            // Ensure the vertex is white in the color map.
            if (nrequest.options.traverseContext.colorMap[startingVertexId] !== colors.white) {
                errors.unshift(&#x22;BFT request failed. Vertex &#x27;&#x22; + startingVertexId + &#x22;&#x27; color map not initialized to white.&#x22;);
                break;
            }

            // startVertex visitor callback.
            if (nrequest.options.signalStart) {
                innerResponse = visitorCallback({ algorithm: algorithmName, visitor: nrequest.visitor, method: &#x27;startVertex&#x27;, request
: { u: startingVertexId, g: nrequest.digraph }});
                if (innerResponse.error) {
                    errors.unshift(innerResponse.error);
                    break;
                }
                continueSearch = innerResponse.result;
            }

            // Conditionally exit the loop if discoverVertex returned false.
            if (errors.length || !continueSearch) {
                break;
            }

            // discoverVertex visitor callback.
            innerResponse = visitorCallback({ algorithm: algorithmName, visitor: nrequest.visitor, method: &#x27;discoverVertex&#x27;, request
: { u: startingVertexId, g: nrequest.digraph }});
            if (innerResponse.error) {
                errors.unshift(innerResponse.error);
                break;
            }
            continueSearch = innerResponse.result;

            // Remove the vertex from the undiscovered vertex map.
            delete nrequest.options.traverseContext.undiscoveredMap[startingVertexId];

            // Add the vertex to the search
            searchQueue.push(startingVertexId);

            // Color the vertex discovered (gray)
            nrequest.options.traverseContext.colorMap[startingVertexId] = colors.gray;

            // Conditionally exit the loop if discoverVertex returned false.
            if (!continueSearch) {
                break;
            }

        } // for initialize search

        // Execute the main breadth-first algorithm using the starting vertex set as the initial contents of the se ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            u: request.e.v,
            p: request.g.getVertexProperty(request.e.u) + 1
        });
        return true;
    }
};
// ACTUATE OUR VISITOR INTERFACE WITH BFT TO PRODUCE THE RESULT
response = jsgraph.<span class="apidocCodeKeywordSpan">directed.breadthFirstTraverse</span>({
    digraph: digraph,
    visitor: bftVisitorInterface
});
if (response.error) {
    throw new Error(response.error);
}
console.log(&#x22;DirectedGraph: &#x27;&#x22; +
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsgraph.directed.create" id="apidoc.element.jsgraph.directed.create">
        function <span class="apidocSignatureSpan">jsgraph.</span>directed.create
        <span class="apidocSignatureSpan">(jsonOrObject_)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">directed.create = function (jsonOrObject_) {
    var response = { error: null, result: null };
    var digraph = new DirectedGraph(jsonOrObject_);
    if (digraph._private.constructionError) {
        response.error = digraph._private.constructionError;
    } else {
        response.result = digraph;
    }
    return response;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

## Example

The following short example constructs a `DirectedGraph` container using a v0.7 jsgraph digraph data object, and derives a simple
 rank assignment algorithm from jsgraph&#x27;s bundled `breadthFirstTraverse` algorithm. Note that the BFT visitor interface callback
 functions leverage the `DirectedGraph` API to get/set the data property value of each visited vertex to its rank.
```javascript
// Encapsule/jsgraph/examples/bft-vertex-ranking.js
var jsgraph = require(&#x27;jsgraph&#x27;);
var response = jsgraph.<span class="apidocCodeKeywordSpan">directed.create</span>({
    elist: [
        { e: { u: &#x22;A&#x22;, v: &#x22;B&#x22; } },
        { e: { u: &#x22;B&#x22;, v: &#x22;C&#x22; } },
        { e: { u: &#x22;B&#x22;, v: &#x22;D&#x22; } }
    ]
});
// Check the response object for error!
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsgraph.directed.createTraversalContext" id="apidoc.element.jsgraph.directed.createTraversalContext">
        function <span class="apidocSignatureSpan">jsgraph.</span>directed.createTraversalContext
        <span class="apidocSignatureSpan">(request_)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">directed.createTraversalContext = function (request_) {
    var response = { error: null, result: null };
    var errors = [];
    var traverseContext = { searchStatus: &#x27;pending&#x27;, colorMap: {}, undiscoveredMap: {} };
    var initializeColorMapRecord = function (vertexId_) {
        traverseContext.colorMap[vertexId_] = colors.white;
        traverseContext.undiscoveredMap[vertexId_] = true;
    };
    var inBreakScope = false;
    while (!inBreakScope) {
        inBreakScope = true;
        var objectTS = &#x27;[object Object]&#x27;;
        // Verify request.
        var type = helperFunctions.JSType(request_);
        if (type !== objectTS) {
            errors.unshift(&#x22;Expected request to be of type &#x27;&#x22; + objectTS + &#x22;&#x27; but found &#x27;&#x22; + type + &#x22;&#x27;.&#x22;);
            break;
        }
        // Verify request.digraph.
        type = helperFunctions.JSType(request_.digraph);
        if (type !== objectTS) {
            errors.unshift(&#x22;Expected request.digraph to be of type &#x27;&#x22; + objectTS + &#x22;&#x27; but found &#x27;&#x22; + type + &#x22;&#x27;.&#x22;);
            break;
        }
        // Initialize the BFS search context object.
        request_.digraph.getVertices().forEach(initializeColorMapRecord);
        // Assign the result. Note that it&#x27;s incumbant upon the first invocation of
        // traversal algorithm  to check/set the traverseContext.searchStatus flag and
        // correctly call the visitor.initializeVertex callback on each vertex in the
        // color map prior to the start of the search. traverseContext.searchStatus should
        // be &#x27;running&#x27; while a search is in progress. &#x27;terminated&#x27; if prematurely terminated
        // by client visitor code. &#x27;complete&#x27; when search concludes normally.
        response.result = traverseContext;
    }
    if (errors.length) {
        errors.unshift(&#x22;jsgraph.directed.createTraverseContext failed:&#x22;);
        response.error = errors.join(&#x27; &#x27;);
    }
    return response;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsgraph.directed.depthFirstTraverse" id="apidoc.element.jsgraph.directed.depthFirstTraverse">
        function <span class="apidocSignatureSpan">jsgraph.</span>directed.depthFirstTraverse
        <span class="apidocSignatureSpan">(request_)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">directed.depthFirstTraverse = function (request_) {

    var nrequest = null; // normalized request
    var response = { error: null, result: null };
    var errors = [];
    var continueSearch = true;
    var inBreakScope = false;

    while (!inBreakScope) {
        inBreakScope = true;
        var index, vertexId;
        var finishedEdges = {};
        var innerRequest = null;
        var hash = null;

        var innerResponse = normalizeRequest(request_);
        if (innerResponse.error) {
            errors.unshift(innerResponse.error);
            break;
        }
        nrequest = innerResponse.result;

        // initializeVertex visitor callback.
        if (nrequest.options.traverseContext.searchStatus === &#x27;pending&#x27;) {
            for (vertexId in nrequest.options.traverseContext.colorMap) {
                innerResponse = visitorCallback({ algorithm: algorithmName, visitor: nrequest.visitor, method: &#x27;initializeVertex
&#x27;, request: { u: vertexId, g: nrequest.digraph }});
                if (innerResponse.error) {
                    errors.unshift(innerResponse.error);
                    break;
                }
                continueSearch = innerResponse.result;
                if (!continueSearch) {
                    break;
                }
            } // end for
        } // if searchStatus &#x27;pending&#x27;

        nrequest.options.traverseContext.searchStatus = &#x27;active&#x27;;

        if (errors.length || !continueSearch) {
            break;
        }

        // Outer depth-first search loop iterates over the start vertex set.
        for (index in nrequest.options.startVector) {

            vertexId = nrequest.options.startVector[index];

            // Ensure the starting vertex is actually in the graph.
            if (!nrequest.digraph.isVertex(vertexId)) {
                errors.unshift(&#x22;DFT request failed. Vertex &#x27;&#x22; + vertexId + &#x22;&#x27; not found in specified directed graph container.&#x22;);
                break;
            }

            // Ensure the starting vertex is undicovered (white in the color map).
            if (nrequest.options.traverseContext.colorMap[vertexId] !== colors.white) {
                errors.unshift(&#x22;DFT request failed. Vertex &#x27;&#x22; + vertexId + &#x22;&#x27; color map not initialized to white.&#x22;);
                break;
            }

            // startVertex visitor callback
            if (nrequest.options.signalStart) {
                innerResponse = visitorCallback({ algorithm: algorithmName, visitor: nrequest.visitor, method: &#x27;startVertex&#x27;, request
: { u: vertexId, g: nrequest.digraph }});
                if (innerResponse.error) {
                    errors.unshift(innerResponse.error);
                    break;
                }
                continueSearch = innerResponse.result;
            }
            if (!continueSearch) {
                break;
            }

            // searchStack is a FILO of FIFO&#x27;s (or stack of queues if you prefer)
            // initialized with starting vertex set member under-evaluation&#x27;s ID.
            var searchStack = [ [ vertexId ] ];

            // Iterate until search stack is empty, a client visitor method returns false, or an error occurs.
            while (searchStack.length &#x26;&#x26; continueSearch &#x26;&#x26; !errors.length) {

                // Peek at the identifier of the vertex at the front of the queue atop the search stack.

                var currentVertexId = (searchStack[searchStack.length - 1])[0];

                switch (nrequest.options.traverseContext.colorMap[currentVertexId]) {

                case colors.white:

                    // Remove the vertex from the undiscovered map.
                    delete nrequest.options.traverseContext.undiscoveredMap[currentVertexId];

                    // Change the vertex&#x27;s state to GRAY to record its discovery.
                    nrequest.options.traverseContext.colorMap[currentVertexId] = colors.gray;

                    // discoverVertex visitor callback.
                    innerResponse = visitorCallback({
                        algorithm: algorithmName,
                        visitor: nrequest.vi ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsgraph.directed.transpose" id="apidoc.element.jsgraph.directed.transpose">
        function <span class="apidocSignatureSpan">jsgraph.</span>directed.transpose
        <span class="apidocSignatureSpan">(digraph_)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">directed.transpose = function (digraph_) {
    var response = { error: null, result: null };
    var errors = [];
    var innerResponse;

    var digraphOut = new DirectedGraph();

    var jstype = helperFunctions.JSType(digraph_);
    if (jstype !== &#x27;[object Object]&#x27;) {
        errors.unshift(&#x22;Expected reference to DirectedGraph but found type &#x27;&#x22; + jstype + &#x22;&#x27;.&#x22;);
    } else {

        digraph_.getVertices().forEach(function(vertexId_) {
            innerResponse = digraphOut.addVertex({ u: vertexId_, p: digraph_.getVertexProperty(vertexId_) });
            if (innerResponse.error) {
                errors.unshift(innerResponse.error);
            }
        });

        digraph_.getEdges().forEach(function(edge_) {
            innerResponse = digraphOut.addEdge({ e: { u: edge_.v, v: edge_.u }, p: digraph_.getEdgeProperty(edge_) });
            if (innerResponse.error) {
                errors.unshift(innerResponse.error);
            }
        });

    } // end else

    if (errors.length) {
        errors.unshift(&#x22;jsgraph.directed.transpose failed:&#x22;);
        response.error = errors.join(&#x27; &#x27;);
    } else {
        response.result = digraphOut;
    }
    return response;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
#### jsgraph.directed.transpose Transform

**See also: [Transform Reference: jsgraph.directed.transpose](./docs/transform-transpose.md)**

jsgraph currently provides a single &#x27;transform&#x27; function, `jsgraph.directed.transpose` that constructs a new `DirectedGraph
` that that is equivalent to an existing `DirectedGraph` except that the direction of all the edges is reversed. Note that vertex
 and edge properties (if any) are copied by reference to the transposed digraph as a deep copy is seldom desirable.

```javascript
var response = jsgraph.<span class="apidocCodeKeywordSpan">directed.transpose</span>(digraph);
if (response.error) {
    console.log(response.error);
} else {
    console.log(&#x22;Transposed digraph JSON: &#x27;&#x22; + response.result.toJSON() + &#x22;&#x27;.&#x22;);
}
```
...</pre></li>
    </ul>












</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jsgraph.arc_core_digraph" id="apidoc.module.jsgraph.arc_core_digraph">module jsgraph.arc_core_digraph</a></h1>


    <h2>
        <a href="#apidoc.element.jsgraph.arc_core_digraph.DirectedGraph" id="apidoc.element.jsgraph.arc_core_digraph.DirectedGraph">
        function <span class="apidocSignatureSpan">jsgraph.arc_core_digraph.</span>DirectedGraph
        <span class="apidocSignatureSpan">(jsonOrObject_)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function DirectedGraph(jsonOrObject_) {

    // Meta methods
    this.getGraphName = __bind(this.getGraphName, this);
    this.setGraphName = __bind(this.setGraphName, this);
    this.getGraphDescription = __bind(this.getGraphDescription, this);
    this.setGraphDescription = __bind(this.setGraphDescription, this);

    // Vertex-scope methods
    this.isVertex = __bind(this.isVertex, this);
    this.addVertex = __bind(this.addVertex, this);
    this.removeVertex = __bind(this.removeVertex, this);
    this.getVertexProperty = __bind(this.getVertexProperty, this);
    this.setVertexProperty = __bind(this.setVertexProperty, this);
    this.hasVertexProperty = __bind(this.hasVertexProperty, this);
    this.clearVertexProperty = __bind(this.clearVertexProperty, this);
    this.inDegree = __bind(this.inDegree, this);
    this.inEdges = __bind(this.inEdges, this);
    this.outDegree = __bind(this.outDegree, this);
    this.outEdges = __bind(this.outEdges, this);

    // Edge-scope methods
    this.isEdge = __bind(this.isEdge, this);
    this.addEdge = __bind(this.addEdge, this);
    this.removeEdge = __bind(this.removeEdge, this);
    this.getEdgeProperty = __bind(this.getEdgeProperty, this);
    this.setEdgeProperty = __bind(this.setEdgeProperty, this);
    this.hasEdgeProperty = __bind(this.hasEdgeProperty, this);
    this.clearEdgeProperty = __bind(this.clearEdgeProperty, this);

    // Digraph-scope methods
    this.verticesCount = __bind(this.verticesCount, this);
    this.getVertices = __bind(this.getVertices, this);
    this.edgesCount = __bind(this.edgesCount, this);
    this.getEdges = __bind(this.getEdges, this);
    this.rootVerticesCount = __bind(this.rootVerticesCount, this);
    this.getRootVertices = __bind(this.getRootVertices, this);
    this.leafVerticesCount = __bind(this.leafVerticesCount, this);
    this.getLeafVertices = __bind(this.getLeafVertices, this);
    this.toJSON = __bind(this.toJSON, this);
    this.toObject = __bind(this.toObject, this);
    this.stringify = __bind(this.stringify, this);
    this.fromObject = __bind(this.fromObject, this);
    this.fromJSON = __bind(this.fromJSON, this);

    // DirectedGraph container private runtime state.
    this._private = {
        name: &#x22;&#x22;,
        description: &#x22;&#x22;,
        vertexMap: {},
        rootMap: {},
        leafMap: {},
        edgeCount: 0,
        constructionError: null
    };
    if ((jsonOrObject_ !== null) &#x26;&#x26; jsonOrObject_) {
        var innerResponse = digraphImport(this, jsonOrObject_);
        if (innerResponse.error) {
            this._private.constructionError = &#x22;DirectedGraph constructor failed: &#x22; + innerResponse.error;
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    response.result = digraph;
}
return response;
    };

    module.exports = {
/*
  createDirectedGraph is a wrapper around JavaScript operator new jsgraph.<span class="apidocCodeKeywordSpan">DirectedGraph</span
>(...)
  that returns an error/result response object. This is the preferred mechanism by which
  jsgraph-derived client code should construct DirectedGraph container object instance(s).
*/
createDirectedGraph: createDirectedGraph,

/*
  DirectedGraph is constructed with JavaScript operator new but may fail during construction
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsgraph.arc_core_digraph.createDirectedGraph" id="apidoc.element.jsgraph.arc_core_digraph.createDirectedGraph">
        function <span class="apidocSignatureSpan">jsgraph.arc_core_digraph.</span>createDirectedGraph
        <span class="apidocSignatureSpan">(jsonOrObject_)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createDirectedGraph = function (jsonOrObject_) {
    var response = { error: null, result: null };
    var digraph = new DirectedGraph(jsonOrObject_);
    if (digraph._private.constructionError) {
        response.error = digraph._private.constructionError;
    } else {
        response.result = digraph;
    }
    return response;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jsgraph.arc_core_digraph_algorithm_request" id="apidoc.module.jsgraph.arc_core_digraph_algorithm_request">module jsgraph.arc_core_digraph_algorithm_request</a></h1>


    <h2>
        <a href="#apidoc.element.jsgraph.arc_core_digraph_algorithm_request.arc_core_digraph_algorithm_request" id="apidoc.element.jsgraph.arc_core_digraph_algorithm_request.arc_core_digraph_algorithm_request">
        function <span class="apidocSignatureSpan">jsgraph.</span>arc_core_digraph_algorithm_request
        <span class="apidocSignatureSpan">(request_)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">arc_core_digraph_algorithm_request = function (request_) {

    var response = { error: null, result: null };
    var errors = [];
    var nrequest = null;
    var inBreakScope = false;

    var createTraverseContext = function() {
        var response = TRAVERSE_CONTEXT({ digraph: nrequest.digraph });
        var result = null;
        if (response.error) {
            errors.unshift(response.error);
        } else {
            result = response.result;
        }
        return result;
    };

    var getRootVertices = function() {
        return nrequest.digraph.getRootVertices();
    };

    while (!inBreakScope) {
        inBreakScope = true;

        // Verify the outer shape of the request object.
        var innerResponse = helperFunctions.JSType(request_);
        if (innerResponse !== &#x27;[object Object]&#x27;) {
            errors.unshift(&#x22;Missing request object ~. Found type &#x27;&#x22; + innerResponse + &#x22;&#x27;.&#x22;);
            break;
        }
        nrequest = {};
        innerResponse = helperFunctions.JSType(request_.digraph);
        if (innerResponse !== &#x27;[object Object]&#x27;) {
            errors.unshift(&#x22;Missing required DirectedGraph reference ~.digraph. Found type &#x27;&#x22; + innerResponse + &#x22;&#x27;.&#x22;);
            break;
        }
        nrequest.digraph = request_.digraph;
        innerResponse = helperFunctions.JSType(request_.visitor);
        if (innerResponse !== &#x27;[object Object]&#x27;) {
            errors.unshift(&#x22;Missing required visitor object reference ~.visitor. Found type &#x27;&#x22; + innerResponse + &#x22;&#x27;.&#x22;);
            break;
        }

        nrequest.visitor = request_.visitor;
        innerResponse = helperFunctions.JSType(request_.options);
        if ((innerResponse !== &#x27;[object Undefined]&#x27;) &#x26;&#x26; (innerResponse !== &#x27;[object Object]&#x27;)) {
            errors.unshift(&#x22;Options object ~.options is the wrong type. Found type &#x27;&#x22; + innerResponse + &#x22;&#x27;.&#x22;);
            break;
        }
        nrequest.options = {};
        if (innerResponse === &#x27;[object Object]&#x27;) {
            innerResponse = helperFunctions.JSType(request_.options.startVector);
            switch (innerResponse) {
            case &#x27;[object Undefined]&#x27;:
                break;
            case &#x27;[object String]&#x27;:
                nrequest.options.startVector = [ request_.options.startVector ];
                break;
            case &#x27;[object Array]&#x27;:
                nrequest.options.startVector = request_.options.startVector;
                break;
            default:
                errors.unshift(&#x22;Options object property ~.options.startVector is the wrong type. Expected either &#x27;[object String
]&#x27;, &#x27;[object Array]&#x27;, or &#x27;[object Undefined]&#x27;. Found type &#x27;&#x22; + innerResponse + &#x22;&#x27;.&#x22;);
                break;
            } // end switch

            if (errors.length) {
                break;
            }

            innerResponse = helperFunctions.JSType(request_.options.allowEmptyStartVector);
            if ((innerResponse !== &#x27;[object Undefined]&#x27;) &#x26;&#x26; (innerResponse !== &#x27;[object Boolean]&#x27;)) {
                errors.unshift(&#x22;Options object property ~.options.allowEmptyStartVector is the wrong type. Expected either &#x27;[object
 Boolean]&#x27; or &#x27;[object Undefined]. Found type &#x27;&#x22; + innerResponse + &#x22;&#x27;.&#x22;);
                break;
            }
            if (innerResponse == &#x27;[object Boolean]&#x27;) {
                nrequest.options.allowEmptyStartVector = request_.options.allowEmptyStartVector;
            }

            innerResponse = helperFunctions.JSType(request_.options.signalStart);
            if ((innerResponse !== &#x27;[object Undefined]&#x27;) &#x26;&#x26; (innerResponse !== &#x27;[object Boolean]&#x27;)) {
                errors.unshift(&#x22;Options object property ~.options.signalStart is the wrong type. Expected either &#x27;[object Boolean
]&#x27; or &#x27;[object Undefined]&#x27;. Found type &#x27;&#x22; + innerResponse + &#x22;&#x27;.&#x22;);
                break;
            }
            if (innerResponse === &#x27;[object Boolean]&#x27;) {
                nrequest.options.signalStart = request_.options.signalStart;
            }


            innerResponse = helperFunctions.JSType(request_.options.traverseContext);
            if ((innerResponse !== &#x27;[object Undefined]&#x27;) &#x26;&#x26; (inner ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jsgraph.arc_core_digraph_algorithm_visit" id="apidoc.module.jsgraph.arc_core_digraph_algorithm_visit">module jsgraph.arc_core_digraph_algorithm_visit</a></h1>


    <h2>
        <a href="#apidoc.element.jsgraph.arc_core_digraph_algorithm_visit.arc_core_digraph_algorithm_visit" id="apidoc.element.jsgraph.arc_core_digraph_algorithm_visit.arc_core_digraph_algorithm_visit">
        function <span class="apidocSignatureSpan">jsgraph.</span>arc_core_digraph_algorithm_visit
        <span class="apidocSignatureSpan">(request_)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">arc_core_digraph_algorithm_visit = function (request_) {

    var response = { error: null, result: null };
    var errors = [];
    var inBreakScope = false;
    while (!inBreakScope) {
        inBreakScope = true;
        var visitorCallback = request_.visitor[request_.method];
        var jstype = helperFunctions.JSType(visitorCallback);
        // If the visitor function is not defined on the visitor object, return true to continue the search.
        if (jstype !== &#x27;[object Function]&#x27;) {
            if (jstype !== &#x27;[object Undefined]&#x27;) {
                errors.unshift(request_.algorithm + &#x22; visitor interface method &#x27;&#x22; + request_.method + &#x22;&#x27; is type &#x27;&#x22; + jstype + &#x22;&#x27;
instead of &#x27;[object Function]&#x27; as expected.&#x22;);
                break;
            }
            response.result = true;
            break;
        }
        var continueSearch = visitorCallback(request_.request);
        jstype = helperFunctions.JSType(continueSearch);
        if (jstype !== &#x27;[object Boolean]&#x27;) {
            errors.unshift(request_.algorithm + &#x22; visitor interface error in callback function &#x27;&#x22; + request_.method + &#x22;&#x27;. Function
 returned type &#x27;&#x22; + jstype + &#x22;&#x27; instead of expected &#x27;[object Boolean]&#x27;.&#x22;);
            break;
        }
        response.result = continueSearch;
    }
    if (errors.length) {
        response.error = errors.join(&#x27; &#x27;);
    }
    return response;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jsgraph.arc_core_digraph_export" id="apidoc.module.jsgraph.arc_core_digraph_export">module jsgraph.arc_core_digraph_export</a></h1>


    <h2>
        <a href="#apidoc.element.jsgraph.arc_core_digraph_export.exportJSON" id="apidoc.element.jsgraph.arc_core_digraph_export.exportJSON">
        function <span class="apidocSignatureSpan">jsgraph.arc_core_digraph_export.</span>exportJSON
        <span class="apidocSignatureSpan">(digraph_, replacer_, space_)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">exportJSON = function (digraph_, replacer_, space_) {
    return JSON.stringify(DigraphDataExporter.exportObject(digraph_), replacer_, space_);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return digraphExport.exportObject(this);
};
DirectedGraph.prototype.toObject = function() {
    return digraphExport.exportObject(this);
};

DirectedGraph.prototype.stringify = function(replacer_, space_) {
    return digraphExport.<span class="apidocCodeKeywordSpan">exportJSON</span>(this, replacer_, space_);
};

DirectedGraph.prototype.fromObject = function (object_) {
    return digraphImport(this, object_);
};

DirectedGraph.prototype.fromJSON = function(json_) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsgraph.arc_core_digraph_export.exportObject" id="apidoc.element.jsgraph.arc_core_digraph_export.exportObject">
        function <span class="apidocSignatureSpan">jsgraph.arc_core_digraph_export.</span>exportObject
        <span class="apidocSignatureSpan">(digraph_)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">exportObject = function (digraph_) {
    var digraphState = {
        name: digraph_.getGraphName(),
        description: digraph_.getGraphDescription(),
        vlist: [],
        elist: []
    };
    var vertexSerialized = {}; // Keep track of the vertices referenced in the edge list.
    var edgeList = digraph_.getEdges();
    var vertexList = digraph_.getVertices();
    digraph_.getEdges().forEach(function(edge_) {
        var edgeProperty = digraph_.getEdgeProperty(edge_);
        digraphState.elist.push({ e: edge_, p: edgeProperty });
        vertexSerialized[edge_.u] = vertexSerialized[edge_.v] = true;
    });
    digraph_.getVertices().forEach(function(vertexId_) {
        var vertexProperty = digraph_.getVertexProperty(vertexId_);
        var jstype = helperFunctions.JSType(vertexProperty);
        // If the vertex has an attached property, serialize it to the vlist.
        if (jstype !== &#x27;[object Undefined]&#x27;) {
            digraphState.vlist.push({ u: vertexId_, p: vertexProperty });
        } else {
            // If the vertex wasn&#x27;t mentioned in the elist, we need to serialize, sans property, to the vlist.
            if (vertexSerialized[vertexId_] !== true) {
                digraphState.vlist.push({ u: vertexId_ });
            }
        }
    });
    return digraphState;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        leafVertices.push(vertexId);
    }
    return leafVertices;
};

// toJSON and toObject are identical delegations to digraphExport.exportObject.
DirectedGraph.prototype.toJSON = function () {
    return digraphExport.<span class="apidocCodeKeywordSpan">exportObject</span>(this);
};
DirectedGraph.prototype.toObject = function() {
    return digraphExport.exportObject(this);
};

DirectedGraph.prototype.stringify = function(replacer_, space_) {
    return digraphExport.exportJSON(this, replacer_, space_);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jsgraph.arc_core_digraph_import" id="apidoc.module.jsgraph.arc_core_digraph_import">module jsgraph.arc_core_digraph_import</a></h1>


    <h2>
        <a href="#apidoc.element.jsgraph.arc_core_digraph_import.arc_core_digraph_import" id="apidoc.element.jsgraph.arc_core_digraph_import.arc_core_digraph_import">
        function <span class="apidocSignatureSpan">jsgraph.</span>arc_core_digraph_import
        <span class="apidocSignatureSpan">(digraph_, jsonOrObject_)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">arc_core_digraph_import = function (digraph_, jsonOrObject_) {

    var jsonParse;
    var getType = function(ref_) { return Object.prototype.toString.call(ref_); };
    var response = { error: null, result: null };
    var errors = [];
    var inBreakScope = false;

    var processVertex = function(vertexDescriptor_) {
        type = getType(vertexDescriptor_);
        if (type !== &#x27;[object Object]&#x27;) {
            errors.unshift(&#x22;JSON semantics error: Expected vertex descriptor object in &#x27;vlist&#x27; array but found &#x27;&#x22; + type + &#x22;&#x27; instead
.&#x22;);
        } else {
            type = getType(vertexDescriptor_.u);
            if (type !== &#x27;[object String]&#x27;) {
                errors.unshift(&#x22;JSON semantics error: Expected vertex descriptor property &#x27;u&#x27; to be a string but found &#x27;&#x22; + type
 + &#x22;&#x27; instead.&#x22;);
            } else {
                digraph_.addVertex({ u: vertexDescriptor_.u, p: vertexDescriptor_.p});
            }
        }
    };

    var processEdge = function (edgeDescriptor_) {
        type = getType(edgeDescriptor_);
        if (type !== &#x27;[object Object]&#x27;) {
            errors.unshift(&#x22;JSON semantics error: Expected edge descriptor object in &#x27;elist&#x27; array but found &#x27;&#x22; + type + &#x22;&#x27; instead
.&#x22;);
        } else {
            type = getType(edgeDescriptor_.e);
            if (type !== &#x27;[object Object]&#x27;) {
                errors.unshift(&#x22;JSON semantics error: Edge record in &#x27;elist&#x27; should define edge descriptor object &#x27;e&#x27; but but found
 &#x27;&#x22; + type + &#x22;&#x27; instead.&#x22;);
            } else {
                type = getType(edgeDescriptor_.e.u);
                if (type !== &#x27;[object String]&#x27;) {
                    errors.unshift(&#x22;JSON semantics error: Expected edge descriptor property &#x27;e.u&#x27; to be a string but found &#x27;&#x22; +
type + &#x22;&#x27; instead.&#x22;);
                } else {
                    type = getType(edgeDescriptor_.e.v);
                    if (type !== &#x27;[object String]&#x27;) {
                        errors.unshift(&#x22;JSON semantics error: Expected edge descriptor property &#x27;e.v&#x27; to be a string but found &#x27;&#x22; +
type + &#x22;&#x27; instead.&#x22;);
                    } else {
                        digraph_.addEdge({ e: edgeDescriptor_.e, p: edgeDescriptor_.p});
                    }
                }
            }
        }
    };

    while (!inBreakScope) {
        inBreakScope = true;

        var type = getType(jsonOrObject_);
        switch (type) {
        case &#x27;[object String]&#x27;:
            try {
                jsonParse = JSON.parse(jsonOrObject_);
            } catch (exception_) {
                errors.unshift(&#x22;Exception occurred while parsing JSON: &#x22; + exception_.message);
            }
            break;
        case &#x27;[object Object]&#x27;:
            jsonParse = jsonOrObject_;
            break;
        default:
            errors.unshift(&#x22;Invalid reference to &#x27;&#x22; + type + &#x22;&#x27; passed instead of expected JSON (or equivalent object) reference
.&#x22;);
        }
        if (errors.length) {
            break;
        }

        type = getType(jsonParse);
        if (type !== &#x27;[object Object]&#x27;) {
            errors.unshift(&#x22;JSON semantics error: Expected top-level object but found &#x27;&#x22; + type + &#x22;&#x27;.&#x22;);
            break;
        }

        type = getType(jsonParse.name);
        switch (type) {
        case &#x27;[object Undefined]&#x27;:
            jsonParse.name = &#x22;&#x22;;
            break;
        case &#x27;[object String]&#x27;:
            break;
        default:
            errors.unshift(&#x22;JSON semantics error: Expected &#x27;name&#x27; to be a string but found &#x27;&#x22; + type + &#x22;&#x27;.&#x22;);
            break;
        }
        digraph_.setGraphName(jsonParse.name);

        type = getType(jsonParse.description);
        switch (type) {
        case &#x27;[object Undefined]&#x27;:
            jsonParse.description = &#x22;&#x22;;
            break;
        case &#x27;[object String]&#x27;:
            break;
        default:
            error.unshift(&#x22;JSON semantics error: Expected &#x27;description&#x27; to be a string but found &#x27;&#x22; + type + &#x22;&#x27;.&#x22;);
            break;
        }
        digraph_.setGraphDescription(jsonParse.description);

        type = getType(jsonParse.vlist);
        switch (type) {
        case &#x27;[object Undefined]&#x27; ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jsgraph.arc_core_digraph_in_params" id="apidoc.module.jsgraph.arc_core_digraph_in_params">module jsgraph.arc_core_digraph_in_params</a></h1>


    <h2>
        <a href="#apidoc.element.jsgraph.arc_core_digraph_in_params.verifyEdgeReadRequest" id="apidoc.element.jsgraph.arc_core_digraph_in_params.verifyEdgeReadRequest">
        function <span class="apidocSignatureSpan">jsgraph.arc_core_digraph_in_params.</span>verifyEdgeReadRequest
        <span class="apidocSignatureSpan">(request_)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">verifyEdgeReadRequest = function (request_) {
    var response = { error: null, result: false };
    var inBreakScope = false;
    while (!inBreakScope) {
        inBreakScope = true;
        var jstype = helperFunctions.JSType(request_);
        if (jstype !== &#x27;[object Object]&#x27;) {
            response.error = &#x22;Invalid value type &#x27;&#x22; + jstype + &#x22;&#x27; found when expecting edge read request object.&#x22;;
            break;
        }
        jstype = helperFunctions.JSType(request_.u);
        if (jstype !== &#x27;[object String]&#x27;) {
            response.error = &#x22;Invalid value type &#x27;&#x22; + jstype + &#x22;&#x27; found looking for vertex ID string property &#x27;u&#x27; in edge read request
 object.&#x22;;
            break;
        }
        jstype = helperFunctions.JSType(request_.v);
        if (jstype !== &#x27;[object String]&#x27;) {
            response.error = &#x22;Invalid value type &#x27;&#x22; + jstype + &#x22;&#x27; found looking for vertex ID string property &#x27;v&#x27; in edge read request
 object.&#x22;;
            break;
        }
        response.result = true;
    }
    return response;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  Note that invalid requests are coalesced as negative responses.
*/
DirectedGraph.prototype.isEdge = function(request_) {
    var response = false;
    var inBreakScope = false;
    while (!inBreakScope) {
        inBreakScope = true;
        if (digraphParams.<span class="apidocCodeKeywordSpan">verifyEdgeReadRequest</span>(request_).error) {
            break;
        }
        var vertexU = this._private.vertexMap[request_.u];
        var vertexV = this._private.vertexMap[request_.v];
        if (!((vertexU !== null) &#x26;&#x26; vertexU &#x26;&#x26; (vertexV !== null) &#x26;&#x26; vertexV)) {
            break;
        }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsgraph.arc_core_digraph_in_params.verifyEdgeWriteRequest" id="apidoc.element.jsgraph.arc_core_digraph_in_params.verifyEdgeWriteRequest">
        function <span class="apidocSignatureSpan">jsgraph.arc_core_digraph_in_params.</span>verifyEdgeWriteRequest
        <span class="apidocSignatureSpan">(request_)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">verifyEdgeWriteRequest = function (request_) {
    var response = { error: null, result: false };
    var inBreakScope = false;
    while (!inBreakScope) {
        inBreakScope = true;
        var jstype = helperFunctions.JSType(request_);
        if (jstype !== &#x27;[object Object]&#x27;) {
            response.error = &#x22;Invalid value type &#x27;&#x22; + jstype + &#x22;&#x27; found when expecting edge write request object.&#x22;;
            break;
        }
        jstype = helperFunctions.JSType(request_.e);
        if (jstype !== &#x27;[object Object]&#x27;) {
            response.error = &#x22;Invalid value type &#x27;&#x22; + jstype + &#x22;&#x27; found looking for edge descriptor object &#x27;e&#x27; in edge write request
 object.&#x22;;
            break;
        }
        jstype = helperFunctions.JSType(request_.e.u);
        if (jstype !== &#x27;[object String]&#x27;) {
            response.error = &#x22;Invalid value type &#x27;&#x22; + jstype + &#x22;&#x27; found looking for vertex ID string property &#x27;e.u&#x27; in edge write
 request object.&#x22;;
            break;
        }
        jstype = helperFunctions.JSType(request_.e.v);
        if (jstype !== &#x27;[object String]&#x27;) {
            response.error = &#x22;Invalid value type &#x27;&#x22; + jstype + &#x22;&#x27; found looking for vertex ID string property &#x27;e.v&#x27; in edge write
 request object.&#x22;;
            break;
        }
        jstype = helperFunctions.JSType(request_.p);
        if (jstype === &#x27;[object Function]&#x27;) {
            response.error = &#x22;Invalid value type &#x27;&#x22; + jstype + &#x22;&#x27; found while insecting edge property &#x27;p&#x27; in edge write request
object. Must be serializable to JSON!&#x22;;
            break;
        }
        response.result = true;
    }
    return response;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 */
DirectedGraph.prototype.addEdge = function (request_) {
    var response = { error: null, result: null };
    var errors = [];
    var inBreakScope = false;
    while (!inBreakScope) {
        inBreakScope = true;
        var innerResponse = digraphParams.<span class="apidocCodeKeywordSpan">verifyEdgeWriteRequest</span>(request_);
        if (innerResponse.error) {
            errors.unshift(innerResponse.error);
            break;
        }
        innerResponse = this.addVertex({ u: request_.e.u });
        if (innerResponse.error) {
            errors.unshift(innerResponse.error);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsgraph.arc_core_digraph_in_params.verifyVertexReadRequest" id="apidoc.element.jsgraph.arc_core_digraph_in_params.verifyVertexReadRequest">
        function <span class="apidocSignatureSpan">jsgraph.arc_core_digraph_in_params.</span>verifyVertexReadRequest
        <span class="apidocSignatureSpan">(request_)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">verifyVertexReadRequest = function (request_) {
    var response = { error: null, result: false };
    var jstype = helperFunctions.JSType(request_);
    if (jstype !== &#x27;[object String]&#x27;) {
        response.error = &#x22;Invalid value type &#x27;&#x22; + jstype + &#x22;&#x27; found when expecting vertex read request. Expected &#x27;[object String
]&#x27;.&#x22;;
    } else {
        response.result = true;
    }
    return response;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }
    return response;
};

// VERTEX-SCOPE METHODS

DirectedGraph.prototype.isVertex = function (vertexId_) {
    var innerResponse = digraphParams.<span class="apidocCodeKeywordSpan">verifyVertexReadRequest</span>(vertexId_);
    if (innerResponse.error) {
        return false;
    }
    var vertex = this._private.vertexMap[vertexId_];
    return (vertex !== null) &#x26;&#x26; vertex &#x26;&#x26; true || false;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsgraph.arc_core_digraph_in_params.verifyVertexWriteRequest" id="apidoc.element.jsgraph.arc_core_digraph_in_params.verifyVertexWriteRequest">
        function <span class="apidocSignatureSpan">jsgraph.arc_core_digraph_in_params.</span>verifyVertexWriteRequest
        <span class="apidocSignatureSpan">(request_)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">verifyVertexWriteRequest = function (request_) {
    var response = { error: null, result: false };
    var inBreakScope = false;
    while (!inBreakScope) {
        inBreakScope = true;
        var jstype = helperFunctions.JSType(request_);
        if (jstype !== &#x27;[object Object]&#x27;) {
            response.error = &#x22;Invalid value type &#x27;&#x22; + jstype + &#x22;&#x27; found when expecting a vertex write request object.&#x22;;
            break;
        }
        jstype = helperFunctions.JSType(request_.u);
        if (jstype !== &#x27;[object String]&#x27;) {
            response.error = &#x22;Invalid value type &#x27;&#x22; + jstype + &#x22;&#x27; found looking for vertex ID string property &#x27;u&#x27; in vertex write
 request object.&#x22;;
            break;
        }
        jstype = helperFunctions.JSType(request_.p);
        if (jstype === &#x27;[object Function]&#x27;) {
            response.error = &#x22;Invalid value type &#x27;&#x22; + jstype + &#x22; found while inspecting vertex property &#x27;p&#x27; in vertex write request
 object. Must be serializable to JSON!&#x22;;
            break;
        }
        response.result = true;
    }
    return response;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 */
DirectedGraph.prototype.addVertex = function (request_) {
    var response = { error: null, result: null };
    var errors = [];
    var inBreakScope = false;
    while (!inBreakScope) {
        inBreakScope = true;
        var innerResponse = digraphParams.<span class="apidocCodeKeywordSpan">verifyVertexWriteRequest</span>(request_);
        if (innerResponse.error) {
            errors.unshift(innerResponse.error);
            break;
        }
        var vertex = this._private.vertexMap[request_.u];
        if ((vertex === null) || !vertex) {
            vertex = this._private.vertexMap[request_.u] = {};
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jsgraph.arc_core_graph_util" id="apidoc.module.jsgraph.arc_core_graph_util">module jsgraph.arc_core_graph_util</a></h1>


    <h2>
        <a href="#apidoc.element.jsgraph.arc_core_graph_util.JSType" id="apidoc.element.jsgraph.arc_core_graph_util.JSType">
        function <span class="apidocSignatureSpan">jsgraph.arc_core_graph_util.</span>JSType
        <span class="apidocSignatureSpan">(reference_)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">JSType = function (reference_) {
    return Object.prototype.toString.call(reference_);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

DirectedGraph.prototype.getGraphName = function() {
    return this._private.name;
};

DirectedGraph.prototype.setGraphName = function(string_) {
    var response = { error: null, result: null };
    if (helperFunctions.<span class="apidocCodeKeywordSpan">JSType</span>(string_) === &#x27;[object String]&#x27;) {
        this._private.name = string_;
        response.result = true;
    } else {
        response.error = &#x22;Invalid graph name specified. Expected &#x27;[object String]&#x27;.&#x22;;
    }
    return response;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsgraph.arc_core_graph_util.setPropertyValueIfUndefined" id="apidoc.element.jsgraph.arc_core_graph_util.setPropertyValueIfUndefined">
        function <span class="apidocSignatureSpan">jsgraph.arc_core_graph_util.</span>setPropertyValueIfUndefined
        <span class="apidocSignatureSpan">(reference_, propertyName_, valueOrFunction_)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setPropertyValueIfUndefined = function (reference_, propertyName_, valueOrFunction_) {
     var type = JSType(reference_[propertyName_]);
    if (type === &#x27;[object Undefined]&#x27;) {
        type = JSType(valueOrFunction_);
        if (type !== &#x27;[object Function]&#x27;) {
            reference_[propertyName_] = valueOrFunction_;
        } else {
            reference_[propertyName_] = valueOrFunction_();
        }
        return true;
    }
    return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }
    if (innerResponse === &#x27;[object Object]&#x27;) {
        nrequest.options.traverseContext = request_.options.traverseContext;
    }

} // end if options object specified

helperFunctions.<span class="apidocCodeKeywordSpan">setPropertyValueIfUndefined</span>(nrequest.options, &#x27;startVector&#x27;,
getRootVertices);
helperFunctions.setPropertyValueIfUndefined(nrequest.options, &#x27;allowEmptyStartVector&#x27;, false);
helperFunctions.setPropertyValueIfUndefined(nrequest.options, &#x27;signalStart&#x27;, true);
helperFunctions.setPropertyValueIfUndefined(nrequest.options, &#x27;traverseContext&#x27;, createTraverseContext);

// Ensure that the starting vertex set is not empty (unless allowed).
if (!nrequest.options.startVector.length &#x26;&#x26; !nrequest.options.allowEmptyStartVector) {
    errors.unshift(&#x22;Traversal aborted because we don&#x27;t know which vertex to start on. Specify a graph that has at least
 one root vertex, explicity specify the start vertex (or vertices) via `request.options.startVector` array, or suppress this error
 by setting `request.options.allowEmptyStartVector` to Boolean true.&#x22;);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jsgraph.directed" id="apidoc.module.jsgraph.directed">module jsgraph.directed</a></h1>


    <h2>
        <a href="#apidoc.element.jsgraph.directed.breadthFirstTraverse" id="apidoc.element.jsgraph.directed.breadthFirstTraverse">
        function <span class="apidocSignatureSpan">jsgraph.directed.</span>breadthFirstTraverse
        <span class="apidocSignatureSpan">(request_)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">breadthFirstTraverse = function (request_) {

    var nrequest = null; // normalized request object
    var response = { error: null, result: null };
    var errors = [];
    var continueSearch = true;
    var inBreakScope = false;
    var searchQueue = [];

    while (!inBreakScope) {
        inBreakScope = true;
        var index, vertexId;

        var innerResponse = normalizeRequest(request_);
        if (innerResponse.error) {
            errors.unshift(innerResponse.error);
            break;
        }
        nrequest = innerResponse.result;

        // initializeVertex visitor callback.
        if (nrequest.options.traverseContext.searchStatus === &#x27;pending&#x27;) {
            for (vertexId in nrequest.options.traverseContext.colorMap) {
                innerResponse = visitorCallback({ algorithm: algorithmName, visitor: nrequest.visitor, method: &#x27;initializeVertex
&#x27;, request: { u: vertexId, g: nrequest.digraph }});
                if (innerResponse.error) {
                    errors.unshift(innerResponse.error);
                    break;
                }
                continueSearch = innerResponse.result;
                if (!continueSearch) {
                    break;
                }
            }
        } // if searchStatus &#x27;pending&#x27;

        nrequest.options.traverseContext.searchStatus = &#x27;active&#x27;;

        if (errors.length || !continueSearch) {
            break;
        }

        // Initialize the BF visit or search.
        // Note that all that distinguishes visit from search is the number of starting vertices. One -&#x3e; visit, N -&#x3e; search.

        for (index in nrequest.options.startVector) {
            var startingVertexId = nrequest.options.startVector[index];
            // Ensure the starting vertex is in the graph container.
            if (!nrequest.digraph.isVertex(startingVertexId)) {
                errors.unshift(&#x22;BFT request failed. Vertex &#x27;&#x22; + startingVertexId + &#x22;&#x27; not found in specfied directed graph container
.&#x22;);
                break;
            }
            // Ensure the vertex is white in the color map.
            if (nrequest.options.traverseContext.colorMap[startingVertexId] !== colors.white) {
                errors.unshift(&#x22;BFT request failed. Vertex &#x27;&#x22; + startingVertexId + &#x22;&#x27; color map not initialized to white.&#x22;);
                break;
            }

            // startVertex visitor callback.
            if (nrequest.options.signalStart) {
                innerResponse = visitorCallback({ algorithm: algorithmName, visitor: nrequest.visitor, method: &#x27;startVertex&#x27;, request
: { u: startingVertexId, g: nrequest.digraph }});
                if (innerResponse.error) {
                    errors.unshift(innerResponse.error);
                    break;
                }
                continueSearch = innerResponse.result;
            }

            // Conditionally exit the loop if discoverVertex returned false.
            if (errors.length || !continueSearch) {
                break;
            }

            // discoverVertex visitor callback.
            innerResponse = visitorCallback({ algorithm: algorithmName, visitor: nrequest.visitor, method: &#x27;discoverVertex&#x27;, request
: { u: startingVertexId, g: nrequest.digraph }});
            if (innerResponse.error) {
                errors.unshift(innerResponse.error);
                break;
            }
            continueSearch = innerResponse.result;

            // Remove the vertex from the undiscovered vertex map.
            delete nrequest.options.traverseContext.undiscoveredMap[startingVertexId];

            // Add the vertex to the search
            searchQueue.push(startingVertexId);

            // Color the vertex discovered (gray)
            nrequest.options.traverseContext.colorMap[startingVertexId] = colors.gray;

            // Conditionally exit the loop if discoverVertex returned false.
            if (!continueSearch) {
                break;
            }

        } // for initialize search

        // Execute the main breadth-first algorithm using the starting vertex set as the initial contents of the se ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            u: request.e.v,
            p: request.g.getVertexProperty(request.e.u) + 1
        });
        return true;
    }
};
// ACTUATE OUR VISITOR INTERFACE WITH BFT TO PRODUCE THE RESULT
response = jsgraph.directed.<span class="apidocCodeKeywordSpan">breadthFirstTraverse</span>({
    digraph: digraph,
    visitor: bftVisitorInterface
});
if (response.error) {
    throw new Error(response.error);
}
console.log(&#x22;DirectedGraph: &#x27;&#x22; +
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsgraph.directed.create" id="apidoc.element.jsgraph.directed.create">
        function <span class="apidocSignatureSpan">jsgraph.directed.</span>create
        <span class="apidocSignatureSpan">(jsonOrObject_)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">create = function (jsonOrObject_) {
    var response = { error: null, result: null };
    var digraph = new DirectedGraph(jsonOrObject_);
    if (digraph._private.constructionError) {
        response.error = digraph._private.constructionError;
    } else {
        response.result = digraph;
    }
    return response;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

## Example

The following short example constructs a `DirectedGraph` container using a v0.7 jsgraph digraph data object, and derives a simple
 rank assignment algorithm from jsgraph&#x27;s bundled `breadthFirstTraverse` algorithm. Note that the BFT visitor interface callback
 functions leverage the `DirectedGraph` API to get/set the data property value of each visited vertex to its rank.
```javascript
// Encapsule/jsgraph/examples/bft-vertex-ranking.js
var jsgraph = require(&#x27;jsgraph&#x27;);
var response = jsgraph.directed.<span class="apidocCodeKeywordSpan">create</span>({
    elist: [
        { e: { u: &#x22;A&#x22;, v: &#x22;B&#x22; } },
        { e: { u: &#x22;B&#x22;, v: &#x22;C&#x22; } },
        { e: { u: &#x22;B&#x22;, v: &#x22;D&#x22; } }
    ]
});
// Check the response object for error!
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsgraph.directed.createTraversalContext" id="apidoc.element.jsgraph.directed.createTraversalContext">
        function <span class="apidocSignatureSpan">jsgraph.directed.</span>createTraversalContext
        <span class="apidocSignatureSpan">(request_)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createTraversalContext = function (request_) {
    var response = { error: null, result: null };
    var errors = [];
    var traverseContext = { searchStatus: &#x27;pending&#x27;, colorMap: {}, undiscoveredMap: {} };
    var initializeColorMapRecord = function (vertexId_) {
        traverseContext.colorMap[vertexId_] = colors.white;
        traverseContext.undiscoveredMap[vertexId_] = true;
    };
    var inBreakScope = false;
    while (!inBreakScope) {
        inBreakScope = true;
        var objectTS = &#x27;[object Object]&#x27;;
        // Verify request.
        var type = helperFunctions.JSType(request_);
        if (type !== objectTS) {
            errors.unshift(&#x22;Expected request to be of type &#x27;&#x22; + objectTS + &#x22;&#x27; but found &#x27;&#x22; + type + &#x22;&#x27;.&#x22;);
            break;
        }
        // Verify request.digraph.
        type = helperFunctions.JSType(request_.digraph);
        if (type !== objectTS) {
            errors.unshift(&#x22;Expected request.digraph to be of type &#x27;&#x22; + objectTS + &#x22;&#x27; but found &#x27;&#x22; + type + &#x22;&#x27;.&#x22;);
            break;
        }
        // Initialize the BFS search context object.
        request_.digraph.getVertices().forEach(initializeColorMapRecord);
        // Assign the result. Note that it&#x27;s incumbant upon the first invocation of
        // traversal algorithm  to check/set the traverseContext.searchStatus flag and
        // correctly call the visitor.initializeVertex callback on each vertex in the
        // color map prior to the start of the search. traverseContext.searchStatus should
        // be &#x27;running&#x27; while a search is in progress. &#x27;terminated&#x27; if prematurely terminated
        // by client visitor code. &#x27;complete&#x27; when search concludes normally.
        response.result = traverseContext;
    }
    if (errors.length) {
        errors.unshift(&#x22;jsgraph.directed.createTraverseContext failed:&#x22;);
        response.error = errors.join(&#x27; &#x27;);
    }
    return response;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsgraph.directed.depthFirstTraverse" id="apidoc.element.jsgraph.directed.depthFirstTraverse">
        function <span class="apidocSignatureSpan">jsgraph.directed.</span>depthFirstTraverse
        <span class="apidocSignatureSpan">(request_)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">depthFirstTraverse = function (request_) {

    var nrequest = null; // normalized request
    var response = { error: null, result: null };
    var errors = [];
    var continueSearch = true;
    var inBreakScope = false;

    while (!inBreakScope) {
        inBreakScope = true;
        var index, vertexId;
        var finishedEdges = {};
        var innerRequest = null;
        var hash = null;

        var innerResponse = normalizeRequest(request_);
        if (innerResponse.error) {
            errors.unshift(innerResponse.error);
            break;
        }
        nrequest = innerResponse.result;

        // initializeVertex visitor callback.
        if (nrequest.options.traverseContext.searchStatus === &#x27;pending&#x27;) {
            for (vertexId in nrequest.options.traverseContext.colorMap) {
                innerResponse = visitorCallback({ algorithm: algorithmName, visitor: nrequest.visitor, method: &#x27;initializeVertex
&#x27;, request: { u: vertexId, g: nrequest.digraph }});
                if (innerResponse.error) {
                    errors.unshift(innerResponse.error);
                    break;
                }
                continueSearch = innerResponse.result;
                if (!continueSearch) {
                    break;
                }
            } // end for
        } // if searchStatus &#x27;pending&#x27;

        nrequest.options.traverseContext.searchStatus = &#x27;active&#x27;;

        if (errors.length || !continueSearch) {
            break;
        }

        // Outer depth-first search loop iterates over the start vertex set.
        for (index in nrequest.options.startVector) {

            vertexId = nrequest.options.startVector[index];

            // Ensure the starting vertex is actually in the graph.
            if (!nrequest.digraph.isVertex(vertexId)) {
                errors.unshift(&#x22;DFT request failed. Vertex &#x27;&#x22; + vertexId + &#x22;&#x27; not found in specified directed graph container.&#x22;);
                break;
            }

            // Ensure the starting vertex is undicovered (white in the color map).
            if (nrequest.options.traverseContext.colorMap[vertexId] !== colors.white) {
                errors.unshift(&#x22;DFT request failed. Vertex &#x27;&#x22; + vertexId + &#x22;&#x27; color map not initialized to white.&#x22;);
                break;
            }

            // startVertex visitor callback
            if (nrequest.options.signalStart) {
                innerResponse = visitorCallback({ algorithm: algorithmName, visitor: nrequest.visitor, method: &#x27;startVertex&#x27;, request
: { u: vertexId, g: nrequest.digraph }});
                if (innerResponse.error) {
                    errors.unshift(innerResponse.error);
                    break;
                }
                continueSearch = innerResponse.result;
            }
            if (!continueSearch) {
                break;
            }

            // searchStack is a FILO of FIFO&#x27;s (or stack of queues if you prefer)
            // initialized with starting vertex set member under-evaluation&#x27;s ID.
            var searchStack = [ [ vertexId ] ];

            // Iterate until search stack is empty, a client visitor method returns false, or an error occurs.
            while (searchStack.length &#x26;&#x26; continueSearch &#x26;&#x26; !errors.length) {

                // Peek at the identifier of the vertex at the front of the queue atop the search stack.

                var currentVertexId = (searchStack[searchStack.length - 1])[0];

                switch (nrequest.options.traverseContext.colorMap[currentVertexId]) {

                case colors.white:

                    // Remove the vertex from the undiscovered map.
                    delete nrequest.options.traverseContext.undiscoveredMap[currentVertexId];

                    // Change the vertex&#x27;s state to GRAY to record its discovery.
                    nrequest.options.traverseContext.colorMap[currentVertexId] = colors.gray;

                    // discoverVertex visitor callback.
                    innerResponse = visitorCallback({
                        algorithm: algorithmName,
                        visitor: nrequest.vi ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsgraph.directed.transpose" id="apidoc.element.jsgraph.directed.transpose">
        function <span class="apidocSignatureSpan">jsgraph.directed.</span>transpose
        <span class="apidocSignatureSpan">(digraph_)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">transpose = function (digraph_) {
    var response = { error: null, result: null };
    var errors = [];
    var innerResponse;

    var digraphOut = new DirectedGraph();

    var jstype = helperFunctions.JSType(digraph_);
    if (jstype !== &#x27;[object Object]&#x27;) {
        errors.unshift(&#x22;Expected reference to DirectedGraph but found type &#x27;&#x22; + jstype + &#x22;&#x27;.&#x22;);
    } else {

        digraph_.getVertices().forEach(function(vertexId_) {
            innerResponse = digraphOut.addVertex({ u: vertexId_, p: digraph_.getVertexProperty(vertexId_) });
            if (innerResponse.error) {
                errors.unshift(innerResponse.error);
            }
        });

        digraph_.getEdges().forEach(function(edge_) {
            innerResponse = digraphOut.addEdge({ e: { u: edge_.v, v: edge_.u }, p: digraph_.getEdgeProperty(edge_) });
            if (innerResponse.error) {
                errors.unshift(innerResponse.error);
            }
        });

    } // end else

    if (errors.length) {
        errors.unshift(&#x22;jsgraph.directed.transpose failed:&#x22;);
        response.error = errors.join(&#x27; &#x27;);
    } else {
        response.result = digraphOut;
    }
    return response;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
#### jsgraph.directed.transpose Transform

**See also: [Transform Reference: jsgraph.directed.transpose](./docs/transform-transpose.md)**

jsgraph currently provides a single &#x27;transform&#x27; function, `jsgraph.directed.transpose` that constructs a new `DirectedGraph
` that that is equivalent to an existing `DirectedGraph` except that the direction of all the edges is reversed. Note that vertex
 and edge properties (if any) are copied by reference to the transposed digraph as a deep copy is seldom desirable.

```javascript
var response = jsgraph.directed.<span class="apidocCodeKeywordSpan">transpose</span>(digraph);
if (response.error) {
    console.log(response.error);
} else {
    console.log(&#x22;Transposed digraph JSON: &#x27;&#x22; + response.result.toJSON() + &#x22;&#x27;.&#x22;);
}
```
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jsgraph.directed.breadthFirstTraverse" id="apidoc.module.jsgraph.directed.breadthFirstTraverse">module jsgraph.directed.breadthFirstTraverse</a></h1>


    <h2>
        <a href="#apidoc.element.jsgraph.directed.breadthFirstTraverse.breadthFirstTraverse" id="apidoc.element.jsgraph.directed.breadthFirstTraverse.breadthFirstTraverse">
        function <span class="apidocSignatureSpan">jsgraph.directed.</span>breadthFirstTraverse
        <span class="apidocSignatureSpan">(request_)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">breadthFirstTraverse = function (request_) {

    var nrequest = null; // normalized request object
    var response = { error: null, result: null };
    var errors = [];
    var continueSearch = true;
    var inBreakScope = false;
    var searchQueue = [];

    while (!inBreakScope) {
        inBreakScope = true;
        var index, vertexId;

        var innerResponse = normalizeRequest(request_);
        if (innerResponse.error) {
            errors.unshift(innerResponse.error);
            break;
        }
        nrequest = innerResponse.result;

        // initializeVertex visitor callback.
        if (nrequest.options.traverseContext.searchStatus === &#x27;pending&#x27;) {
            for (vertexId in nrequest.options.traverseContext.colorMap) {
                innerResponse = visitorCallback({ algorithm: algorithmName, visitor: nrequest.visitor, method: &#x27;initializeVertex
&#x27;, request: { u: vertexId, g: nrequest.digraph }});
                if (innerResponse.error) {
                    errors.unshift(innerResponse.error);
                    break;
                }
                continueSearch = innerResponse.result;
                if (!continueSearch) {
                    break;
                }
            }
        } // if searchStatus &#x27;pending&#x27;

        nrequest.options.traverseContext.searchStatus = &#x27;active&#x27;;

        if (errors.length || !continueSearch) {
            break;
        }

        // Initialize the BF visit or search.
        // Note that all that distinguishes visit from search is the number of starting vertices. One -&#x3e; visit, N -&#x3e; search.

        for (index in nrequest.options.startVector) {
            var startingVertexId = nrequest.options.startVector[index];
            // Ensure the starting vertex is in the graph container.
            if (!nrequest.digraph.isVertex(startingVertexId)) {
                errors.unshift(&#x22;BFT request failed. Vertex &#x27;&#x22; + startingVertexId + &#x22;&#x27; not found in specfied directed graph container
.&#x22;);
                break;
            }
            // Ensure the vertex is white in the color map.
            if (nrequest.options.traverseContext.colorMap[startingVertexId] !== colors.white) {
                errors.unshift(&#x22;BFT request failed. Vertex &#x27;&#x22; + startingVertexId + &#x22;&#x27; color map not initialized to white.&#x22;);
                break;
            }

            // startVertex visitor callback.
            if (nrequest.options.signalStart) {
                innerResponse = visitorCallback({ algorithm: algorithmName, visitor: nrequest.visitor, method: &#x27;startVertex&#x27;, request
: { u: startingVertexId, g: nrequest.digraph }});
                if (innerResponse.error) {
                    errors.unshift(innerResponse.error);
                    break;
                }
                continueSearch = innerResponse.result;
            }

            // Conditionally exit the loop if discoverVertex returned false.
            if (errors.length || !continueSearch) {
                break;
            }

            // discoverVertex visitor callback.
            innerResponse = visitorCallback({ algorithm: algorithmName, visitor: nrequest.visitor, method: &#x27;discoverVertex&#x27;, request
: { u: startingVertexId, g: nrequest.digraph }});
            if (innerResponse.error) {
                errors.unshift(innerResponse.error);
                break;
            }
            continueSearch = innerResponse.result;

            // Remove the vertex from the undiscovered vertex map.
            delete nrequest.options.traverseContext.undiscoveredMap[startingVertexId];

            // Add the vertex to the search
            searchQueue.push(startingVertexId);

            // Color the vertex discovered (gray)
            nrequest.options.traverseContext.colorMap[startingVertexId] = colors.gray;

            // Conditionally exit the loop if discoverVertex returned false.
            if (!continueSearch) {
                break;
            }

        } // for initialize search

        // Execute the main breadth-first algorithm using the starting vertex set as the initial contents of the se ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            u: request.e.v,
            p: request.g.getVertexProperty(request.e.u) + 1
        });
        return true;
    }
};
// ACTUATE OUR VISITOR INTERFACE WITH BFT TO PRODUCE THE RESULT
response = jsgraph.directed.<span class="apidocCodeKeywordSpan">breadthFirstTraverse</span>({
    digraph: digraph,
    visitor: bftVisitorInterface
});
if (response.error) {
    throw new Error(response.error);
}
console.log(&#x22;DirectedGraph: &#x27;&#x22; +
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jsgraph.directed.create" id="apidoc.module.jsgraph.directed.create">module jsgraph.directed.create</a></h1>


    <h2>
        <a href="#apidoc.element.jsgraph.directed.create.create" id="apidoc.element.jsgraph.directed.create.create">
        function <span class="apidocSignatureSpan">jsgraph.directed.</span>create
        <span class="apidocSignatureSpan">(jsonOrObject_)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">create = function (jsonOrObject_) {
    var response = { error: null, result: null };
    var digraph = new DirectedGraph(jsonOrObject_);
    if (digraph._private.constructionError) {
        response.error = digraph._private.constructionError;
    } else {
        response.result = digraph;
    }
    return response;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

## Example

The following short example constructs a `DirectedGraph` container using a v0.7 jsgraph digraph data object, and derives a simple
 rank assignment algorithm from jsgraph&#x27;s bundled `breadthFirstTraverse` algorithm. Note that the BFT visitor interface callback
 functions leverage the `DirectedGraph` API to get/set the data property value of each visited vertex to its rank.
```javascript
// Encapsule/jsgraph/examples/bft-vertex-ranking.js
var jsgraph = require(&#x27;jsgraph&#x27;);
var response = jsgraph.directed.<span class="apidocCodeKeywordSpan">create</span>({
    elist: [
        { e: { u: &#x22;A&#x22;, v: &#x22;B&#x22; } },
        { e: { u: &#x22;B&#x22;, v: &#x22;C&#x22; } },
        { e: { u: &#x22;B&#x22;, v: &#x22;D&#x22; } }
    ]
});
// Check the response object for error!
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jsgraph.directed.createTraversalContext" id="apidoc.module.jsgraph.directed.createTraversalContext">module jsgraph.directed.createTraversalContext</a></h1>


    <h2>
        <a href="#apidoc.element.jsgraph.directed.createTraversalContext.createTraversalContext" id="apidoc.element.jsgraph.directed.createTraversalContext.createTraversalContext">
        function <span class="apidocSignatureSpan">jsgraph.directed.</span>createTraversalContext
        <span class="apidocSignatureSpan">(request_)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createTraversalContext = function (request_) {
    var response = { error: null, result: null };
    var errors = [];
    var traverseContext = { searchStatus: &#x27;pending&#x27;, colorMap: {}, undiscoveredMap: {} };
    var initializeColorMapRecord = function (vertexId_) {
        traverseContext.colorMap[vertexId_] = colors.white;
        traverseContext.undiscoveredMap[vertexId_] = true;
    };
    var inBreakScope = false;
    while (!inBreakScope) {
        inBreakScope = true;
        var objectTS = &#x27;[object Object]&#x27;;
        // Verify request.
        var type = helperFunctions.JSType(request_);
        if (type !== objectTS) {
            errors.unshift(&#x22;Expected request to be of type &#x27;&#x22; + objectTS + &#x22;&#x27; but found &#x27;&#x22; + type + &#x22;&#x27;.&#x22;);
            break;
        }
        // Verify request.digraph.
        type = helperFunctions.JSType(request_.digraph);
        if (type !== objectTS) {
            errors.unshift(&#x22;Expected request.digraph to be of type &#x27;&#x22; + objectTS + &#x22;&#x27; but found &#x27;&#x22; + type + &#x22;&#x27;.&#x22;);
            break;
        }
        // Initialize the BFS search context object.
        request_.digraph.getVertices().forEach(initializeColorMapRecord);
        // Assign the result. Note that it&#x27;s incumbant upon the first invocation of
        // traversal algorithm  to check/set the traverseContext.searchStatus flag and
        // correctly call the visitor.initializeVertex callback on each vertex in the
        // color map prior to the start of the search. traverseContext.searchStatus should
        // be &#x27;running&#x27; while a search is in progress. &#x27;terminated&#x27; if prematurely terminated
        // by client visitor code. &#x27;complete&#x27; when search concludes normally.
        response.result = traverseContext;
    }
    if (errors.length) {
        errors.unshift(&#x22;jsgraph.directed.createTraverseContext failed:&#x22;);
        response.error = errors.join(&#x27; &#x27;);
    }
    return response;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jsgraph.directed.depthFirstTraverse" id="apidoc.module.jsgraph.directed.depthFirstTraverse">module jsgraph.directed.depthFirstTraverse</a></h1>


    <h2>
        <a href="#apidoc.element.jsgraph.directed.depthFirstTraverse.depthFirstTraverse" id="apidoc.element.jsgraph.directed.depthFirstTraverse.depthFirstTraverse">
        function <span class="apidocSignatureSpan">jsgraph.directed.</span>depthFirstTraverse
        <span class="apidocSignatureSpan">(request_)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">depthFirstTraverse = function (request_) {

    var nrequest = null; // normalized request
    var response = { error: null, result: null };
    var errors = [];
    var continueSearch = true;
    var inBreakScope = false;

    while (!inBreakScope) {
        inBreakScope = true;
        var index, vertexId;
        var finishedEdges = {};
        var innerRequest = null;
        var hash = null;

        var innerResponse = normalizeRequest(request_);
        if (innerResponse.error) {
            errors.unshift(innerResponse.error);
            break;
        }
        nrequest = innerResponse.result;

        // initializeVertex visitor callback.
        if (nrequest.options.traverseContext.searchStatus === &#x27;pending&#x27;) {
            for (vertexId in nrequest.options.traverseContext.colorMap) {
                innerResponse = visitorCallback({ algorithm: algorithmName, visitor: nrequest.visitor, method: &#x27;initializeVertex
&#x27;, request: { u: vertexId, g: nrequest.digraph }});
                if (innerResponse.error) {
                    errors.unshift(innerResponse.error);
                    break;
                }
                continueSearch = innerResponse.result;
                if (!continueSearch) {
                    break;
                }
            } // end for
        } // if searchStatus &#x27;pending&#x27;

        nrequest.options.traverseContext.searchStatus = &#x27;active&#x27;;

        if (errors.length || !continueSearch) {
            break;
        }

        // Outer depth-first search loop iterates over the start vertex set.
        for (index in nrequest.options.startVector) {

            vertexId = nrequest.options.startVector[index];

            // Ensure the starting vertex is actually in the graph.
            if (!nrequest.digraph.isVertex(vertexId)) {
                errors.unshift(&#x22;DFT request failed. Vertex &#x27;&#x22; + vertexId + &#x22;&#x27; not found in specified directed graph container.&#x22;);
                break;
            }

            // Ensure the starting vertex is undicovered (white in the color map).
            if (nrequest.options.traverseContext.colorMap[vertexId] !== colors.white) {
                errors.unshift(&#x22;DFT request failed. Vertex &#x27;&#x22; + vertexId + &#x22;&#x27; color map not initialized to white.&#x22;);
                break;
            }

            // startVertex visitor callback
            if (nrequest.options.signalStart) {
                innerResponse = visitorCallback({ algorithm: algorithmName, visitor: nrequest.visitor, method: &#x27;startVertex&#x27;, request
: { u: vertexId, g: nrequest.digraph }});
                if (innerResponse.error) {
                    errors.unshift(innerResponse.error);
                    break;
                }
                continueSearch = innerResponse.result;
            }
            if (!continueSearch) {
                break;
            }

            // searchStack is a FILO of FIFO&#x27;s (or stack of queues if you prefer)
            // initialized with starting vertex set member under-evaluation&#x27;s ID.
            var searchStack = [ [ vertexId ] ];

            // Iterate until search stack is empty, a client visitor method returns false, or an error occurs.
            while (searchStack.length &#x26;&#x26; continueSearch &#x26;&#x26; !errors.length) {

                // Peek at the identifier of the vertex at the front of the queue atop the search stack.

                var currentVertexId = (searchStack[searchStack.length - 1])[0];

                switch (nrequest.options.traverseContext.colorMap[currentVertexId]) {

                case colors.white:

                    // Remove the vertex from the undiscovered map.
                    delete nrequest.options.traverseContext.undiscoveredMap[currentVertexId];

                    // Change the vertex&#x27;s state to GRAY to record its discovery.
                    nrequest.options.traverseContext.colorMap[currentVertexId] = colors.gray;

                    // discoverVertex visitor callback.
                    innerResponse = visitorCallback({
                        algorithm: algorithmName,
                        visitor: nrequest.vi ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jsgraph.directed.transpose" id="apidoc.module.jsgraph.directed.transpose">module jsgraph.directed.transpose</a></h1>


    <h2>
        <a href="#apidoc.element.jsgraph.directed.transpose.transpose" id="apidoc.element.jsgraph.directed.transpose.transpose">
        function <span class="apidocSignatureSpan">jsgraph.directed.</span>transpose
        <span class="apidocSignatureSpan">(digraph_)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">transpose = function (digraph_) {
    var response = { error: null, result: null };
    var errors = [];
    var innerResponse;

    var digraphOut = new DirectedGraph();

    var jstype = helperFunctions.JSType(digraph_);
    if (jstype !== &#x27;[object Object]&#x27;) {
        errors.unshift(&#x22;Expected reference to DirectedGraph but found type &#x27;&#x22; + jstype + &#x22;&#x27;.&#x22;);
    } else {

        digraph_.getVertices().forEach(function(vertexId_) {
            innerResponse = digraphOut.addVertex({ u: vertexId_, p: digraph_.getVertexProperty(vertexId_) });
            if (innerResponse.error) {
                errors.unshift(innerResponse.error);
            }
        });

        digraph_.getEdges().forEach(function(edge_) {
            innerResponse = digraphOut.addEdge({ e: { u: edge_.v, v: edge_.u }, p: digraph_.getEdgeProperty(edge_) });
            if (innerResponse.error) {
                errors.unshift(innerResponse.error);
            }
        });

    } // end else

    if (errors.length) {
        errors.unshift(&#x22;jsgraph.directed.transpose failed:&#x22;);
        response.error = errors.join(&#x27; &#x27;);
    } else {
        response.result = digraphOut;
    }
    return response;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
#### jsgraph.directed.transpose Transform

**See also: [Transform Reference: jsgraph.directed.transpose](./docs/transform-transpose.md)**

jsgraph currently provides a single &#x27;transform&#x27; function, `jsgraph.directed.transpose` that constructs a new `DirectedGraph
` that that is equivalent to an existing `DirectedGraph` except that the direction of all the edges is reversed. Note that vertex
 and edge properties (if any) are copied by reference to the transposed digraph as a deep copy is seldom desirable.

```javascript
var response = jsgraph.directed.<span class="apidocCodeKeywordSpan">transpose</span>(digraph);
if (response.error) {
    console.log(response.error);
} else {
    console.log(&#x22;Transposed digraph JSON: &#x27;&#x22; + response.result.toJSON() + &#x22;&#x27;.&#x22;);
}
```
...</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
